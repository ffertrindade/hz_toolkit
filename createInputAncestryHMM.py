#!/usr/bin/python
# This script estimates allele counts for two parental panels and hybrid individuals and geerates a file that can be used as input for aHMM
# Requires maf estimates for each parental population (generated by using angsd4aHMMinput.sh, for example), which includes only AIMs
# Requires a list of bam files for the hybrids

import gzip
import os
import sys

### parsing arguments
if len(sys.argv) != 8:
	print("Usage: createInputAncestryHMM.py mafPop1 nIndPop1 mafPop2 nIndPop2 bamlistHyb nIndHyb outFile")
	exit()

else:
	nInd=[]
	input=[]
	my_args = sys.argv

	i=1
	while i < len(my_args):
		if i%2 == 0:
			nInd.append(my_args[i])
		else:
			if os.path.isfile(my_args[i]) or i == len(my_args)-1:
				input.append(my_args[i])

			else:
				print("Input file", my_args[i],"doesnt exist!")
				exit()

		i+=1

print(nInd)
print(input)

### checking parental sites position - to prepare aHMM file only for overlaid called sites
def get_sites(maf_pop_file):
	sites_pop=[]
	with gzip.open(maf_pop_file) as file:
		next(file)
		for row in file:
			chr = str(row.split()[0], "utf-8")
			pos = str(row.split()[1], "utf-8")
			sites_pop.append(chr+'_'+pos)
	file.close()
	return sites_pop

sites_pop1 = get_sites(input[0])
sites_pop2 = get_sites(input[1])

# creating a list of common sites between the parental populations
sites_final = []
for a in sites_pop1:
	for b in sites_pop2:
		if a == b:
			sites_final.append(a)

# saving this list in a file to use further in samtools mpileup step
sites_file_name = input[0]+'-'+input[1]
sites_file_name = sites_file_name.replace('.mafs.gz', '', 2)
with open(sites_file_name+"-sites.txt", "w") as sites_file:
	for row in sites_final:
		chr = row.split("_")[0]
		pos = row.split("_")[1]
		print(f"{chr}\t{pos}", file=sites_file)
sites_file.close()

### picking parentals minor/major order - important to coorectly estimate counts for each allele
# getting major/minor and frequencies if specific sites from a maf file
def get_major_minor(sites, maf_pop_file):
	maj_min=[]
	for s in sites:
		with gzip.open(maf_pop_file) as file:
			next(file)
			for row in file:
				chr_pos_row = str(row.split()[0], "utf-8")+"_"+str(row.split()[1], "utf-8")
				if s == chr_pos_row: # to maintain all sites in the same order
					maj = str(row.split()[2], "utf-8")
					min = str(row.split()[3], "utf-8")
					freq = str(row.split()[4], "utf-8")
					maj_min.append(maj+'_'+min+'_'+freq)
	file.close()
	return maj_min

pop1_maj_min = get_major_minor(sites_final, input[0])
pop2_maj_min = get_major_minor(sites_final, input[1])

print(pop1_maj_min)
print(pop2_maj_min)

# verifying the order - if "A/G" are major/minor for pop1 and "G/A" are the major/minor for pop2
ale_pop2_order=[] # 0: same order as pop1; 1: reverse order; 2: only major equal; 3: only minor equal
major_pop1=[]
minor_pop1=[]
major_pop2=[]
minor_pop2=[]
i=0
while i < len(pop1_maj_min):

	# getting base alleles
	major_pop1.append(pop1_maj_min[i].split("_")[0])
	minor_pop1.append(pop1_maj_min[i].split("_")[1])

	major_pop2.append(pop2_maj_min[i].split("_")[0])
	minor_pop2.append(pop2_maj_min[i].split("_")[1])

	# verifying major/minor order of pop2 with respect to pop1
	if major_pop1[i] == major_pop2[i] and minor_pop1[i] == minor_pop2[i]:
		ale_pop2_order.append("0")
	elif major_pop1[i] == major_pop2[i] and minor_pop1[i] != minor_pop2[i]:
		ale_pop2_order.append("2")
	elif major_pop1[i] != major_pop2[i] and minor_pop1[i] == minor_pop2[i]:
		ale_pop2_order.append("3")
	else:
		ale_pop2_order.append("1")

	i+=1

print(ale_pop2_order)

### performing allele counts for the parental panels
def get_parental_counts(pop_maj_min, nInd, pop2_order=""):
	final_counts=[]
	if pop2_order == "":

		for site in pop_maj_min:
			freq = site.split("_")[2]
			maj_count = float(freq)*2*int(nInd)
			min_count = (1-float(freq))*2*int(nInd)
			final_counts.append(str(round(maj_count))+'_'+str(round(min_count)))

	else:
		s=0
		for site in pop_maj_min:
			freq = site.split("_")[2]

			if pop2_order[s] == "0": # 0: same order pop1 and pop2
				maj_count = float(freq)*2*int(nInd)
				min_count = (1-float(freq))*2*int(nInd)
				final_counts.append(str(round(maj_count))+'_'+str(round(min_count)))

			elif pop2_order[s] == "1": # 1: reverse order
				min_count = float(freq)*2*int(nInd)
				maj_count = (1-float(freq))*2*int(nInd)
				final_counts.append(str(round(maj_count))+'_'+str(round(min_count)))

			else: # 2: only major equal; 3: only minor equal; remove this site
				final_counts.append('0_0')

	return final_counts

pop1_counts = get_parental_counts(pop1_maj_min, int(nInd[0]))
pop2_counts = get_parental_counts(pop2_maj_min, int(nInd[1]), ale_pop2_order)

print(pop1_counts)
print(pop2_counts)

### perform allele counts for the hybrids
# running mpileup to generate base counts for the hybrids (only for the sites_final)
samtools_out = input[2]+'.pileup'
#cmd = "samtools mpileup -a -l {0} -q 24 -Q 20 -b {1} > {2}; gzip {2}".format(sites_file_name+"-sites.txt", input[2], samtools_out)
#print(cmd)
#os.system(cmd)

# counting major and minor
num_ind_hibr=int(nInd[2])
col_num=(num_ind_hibr*3)+4 # max col number of mpileup output file based on number of individuals
i=4 # first individual's column alleles in the mpileup output
hib_counts=[]
with gzip.open(samtools_out+".gz") as file:
	l=0
	for row in file:

		site_counts=[]
		while i < col_num:
			alleles = str(row.split()[i], "utf-8")
			al = alleles.upper()
			site_counts.append(str(al.count(major_pop1[l]))+'_'+str(al.count(minor_pop1[l])))
			i+=3

		hib_counts.append(site_counts)
		l+=1
		i=4

print(hib_counts)

### generating the output
# chr pos pop1A pop1a pop2A pop2a morgans sam1A sam1a sam2A sam2a
with open(input[3], "w+") as output:
	i=0
	while i < len(sites_final):
		site = sites_final[i]
		chr = site.split("_")[0]
		pos = site.split("_")[1]

		pop1A = pop1_counts[i].split("_")[0]
		pop1a = pop1_counts[i].split("_")[1]

		pop2A = pop2_counts[i].split("_")[0]
		pop2a = pop2_counts[i].split("_")[1]

		morg = 1

		hc=[]
		for h in hib_counts[i]:
			hc.append(h.split("_")[0])
			hc.append(h.split("_")[1])

		hib = "\t".join(hc)

		print(f"{chr}\t{pos}\t{pop1A}\t{pop1a}\t{pop2A}\t{pop2a}\t{morg}\t{hib}", file=output)
		i+=1

output.close()

"""
Example of a maf file (generated with ANGSD):

chromo  position        major   minor   knownEM nInd
ChrA1   18399   T       C       0.286240        19
ChrA1   18410   T       C       0.301896        19
ChrA1   22719   A       G       0.162857        21
ChrA1   22737   T       G       0.301006        14
ChrA1   23267   A       G       0.167348        19
ChrA1   23312   A       G       0.156889        20
ChrA1   23859   A       G       0.071042        21
ChrA1   32649   A       C       0.377877        17
ChrA1   32927   T       C       0.074211        21
"""

"""
Example of an incomplete samtools mpileup file (generated within this script):

ChrA1   18399   N       0       *       *       12      cCtttttttttt    JJJJJJJJFFJF    2       Ct      JJ      4       tttt    FJAJ    10      ttt
ChrA1   22737   N       0       *       *       2       tt      FJ      0       *       *       5       GGGGG   JJJJF   0       *       *       2
ChrA1   23267   N       1       g       J       3       AAa     JJJ     9       Aaaaaaaaa       JJJJFJJJF       21      gGGAGGGGGGGagggggggAg   JJJ
ChrA1   23312   N       2       gG      Js      36      AaAAAAAAAaaaaaaaaaaaaaaaaaaAAaAAAaAA    JJJJJJJJJJJJFJJJJFJJJJFJJJJFJ<JFJFAA    3       AaA
ChrA1   23859   N       1       A       J       72      aAAAAAAAAAAAAAAAAAAaaaaaaaaaaaaAAAAAAAaAaaAAAAAAAAaaAaAAAAAAAAAaaaaaaAAA        JJFJJJJFJJJ
ChrA1   32649   N       0       *       *       2       A^ZC    JA      2       AA      JJ      2       AA      JJ      2       ^]C^]C  AA      1
ChrA1   32649   N       0       *       *       2       A^ZC    JA      2       AA      JJ      2       AA      JJ      2       ^]C^]C  AA      1
"""
